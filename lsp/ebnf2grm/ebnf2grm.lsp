;;; ============================================================
;;; AMOS2
;;; 
;;; Author: (c) 2010-2014, Andrej Andrejev, UDBL
;;; $RCSfile: ebnf2grm.lsp,v $
;;; $Revision: 1.3 $ $Date: 2014/06/01 20:11:42 $
;;; $State: Exp $ $Locker:  $
;;;
;;; Description: EBNF to GRM grammar converter
;;; =============================================================
;;; $Log: ebnf2grm.lsp,v $
;;; Revision 1.3  2014/06/01 20:11:42  andan342
;;; Made grammar converters loadable on top of SSDM image
;;;
;;;
;;; =============================================================

(unless (boundp '_file_reader_loaded_)
  (load "../file-reader.lsp"))

(unless (boundp 'nlt)
  (load "../parse-utils.lsp"))

(defun ebnf-lexer (fr)
  "Simple state-machine implementing tokenizer of EBNF grammar files, uses FILE-READER struct"
  (do ((ch nil))
      (nil nil) ; never return normally     
    (setq ch (fr-nextchar fr)) ; read next character
    (selectq (fr-lexerstate fr)
	     (:start (cond 
		      ((string= ch "") (return nil))
		      ((string= ch ":") (fr-newstate fr :after-colon))
		      ((string= ch "|") (return '(bar)))
		      ((string= ch "?") (return '(question)))
		      ((string= ch "+") (return '(plus)))
		      ((string= ch "*") (return '(asterisk)))
		      ((string= ch "(") (return '(left-par)))
		      ((string= ch ")") (return '(right-par)))
		      ((string= ch "[") (return '(left-bracket)))
		      ((string= ch "]") (return '(right-bracket)))
		      ((string= ch "/") (fr-newstate fr :after-slash))
		      ((string= ch "'") 
		       (fr-startbuffer fr 1) 
		       (fr-newstate fr :string))
		      ((digit-p ch)
		       (fr-startbuffer fr 0)
		       (fr-newstate fr :integer))
		      ((or (basechar-p ch) (string= ch "<"))
		       (fr-startbuffer fr 0)
		       (fr-newstate fr :id))))
	     (:after-colon (if (string= ch ":") (fr-newstate fr :after-cc)
			     (error "Invalid symbol: :" nil)))
	     (:after-cc (if (string= ch "=") (progn (fr-newstate fr :start) (return '(cce)))
			  (error "Invalid symbol: ::" nil)))
	     (:after-slash (if (string= ch "*") (fr-newstate fr :comment)
			     (error "Invalid symbol: /")))
	     (:comment (when (string= ch "*") (fr-newstate fr :comment-after-asterisk))) ; until "*/"
	     (:comment-after-asterisk (if (string= ch "/") (fr-newstate fr :start)
					(unless (string= ch "*") (fr-newstate fr :comment))))
	     ;; reading identifiers
	     (:id (unless (or (basechar-p ch) (digit-p ch) (string= ch ">"))
		    (fr-newstate fr :start) 
		    (fr-pushback fr ch) ;; hold CH to process it next time
		    (return (cons 'id (fr-popbuffer fr)))))
	     (:integer (unless (digit-p ch)
			 (fr-newstate fr :start)
			 (fr-pushback fr ch) ; CH is still to be processed
			 (return (cons 'int (fr-popbuffer fr)))))
	     ;; reading strings
	     (:string (when (string= ch "'") ; until non-escaped string-opener
			(fr-newstate fr :start) 
			(return (cons 'string (fr-popbuffer fr)))))
	     t)))

(defun print-ebnf-lexems (filename)
  (let ((fr (fr-open filename)))
    (unwind-protect
	(do ((token t))
	    ((null token) t)
	  (setq token (ebnf-lexer fr))
	  (print token))
      (fr-close fr))))

(load "ebnf-parser-datamodel.lsp")

(load "ebnf-slr1.lsp")

(defun parse-ebnf-rules (sourcefile outs ntab)
  "Syntax parser of EBNF grammar files"
  (let ((fr (fr-open sourcefile)) res
	(data (make-ebnf-parser-data :outs outs :ntab ntab)))
    (unwind-protect
	(progn
	  (setq res (ebnf-slr1-parser (f/l () (ebnf-lexer fr)) data)) ; run SLR(1) parser routine
	  (if (and (listp res) (eq (car res) 'syntax-error))
	      (error (concat "Syntax error at Line " (fr-line fr) " Col " (fr-col fr) 
			     ": Input: " (fourth res) " Expected: " (third res) " at state " (second res)))
	    data))      
      (fr-close fr))))

(defun ebnf2grm (sourcefile targetfile targetsymbol)
  "Traslator of EBNF grammar files to GRM format"
  (let* ((ntab (+ (length targetsymbol) 25))
	 (outs (openstream targetfile "w")) res nts)
    (unwind-protect
	(progn
	  (formatl outs ";;; GRM translation of file " sourcefile t
		  ";;; generated by ebnf2grm (C) 2011, Andrej Andrejev" t t
		  "(defparameter " targetsymbol "-grammar '(" t)	 
	  (setq res (parse-ebnf-rules sourcefile outs ntab))
	  (dolist (rule (ebnf-parser-data-rules res)) ;1st pass - collect NTs
	    (unless (member (ebnf-rule-left rule) nts)
	      (push (ebnf-rule-left rule) nts)))
	  (dolist (rule (nreverse (ebnf-parser-data-rules res))) ;2nd pass - print rules
	    (print-ebnf-rule rule res nts))
	  (spaces ntab outs)
	  (formatl outs "))" t t)
	  (formatl outs ";;; This will generate SLR(1) parser, ascend.lsp should be loaded first" t
		   "(make-slr1-parser (grammar-from-johnsons " targetsymbol "-grammar) nil \"" 
		   targetsymbol "-slr1\" \"" targetsymbol  "-slr1.lsp\" nil)" t t)
	  (when (ebnf-parser-data-string-to-term res)
	    (formatl outs ";;; The following terminal symbols were substituted:" t)
	    (dolist (s2t (nreverse (ebnf-parser-data-string-to-term res)))
	      (formatl outs ";; " (cdr s2t) " = " (car s2t) t))))      
      (closestream outs)) t))
	  
		       
